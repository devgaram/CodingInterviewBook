package algorithm;

public class ExhaustiveSearch {

	/*
	 * 완전탐색 : 가능한 방법을 전부 만들어보는 알고리즘
	 * 
	 * 1. Brute Force : for문과 if문을 이용해 처음부터 끝까지 탐색하는 방법
	 * 2. 비트마스크
	 * 3. 순열
	 * 4. 백트래킹
	 * 5. BFS & DFS
	 * 
	 * Q2309 일곱 난쟁이
	 * - 연습삼아 비트마스크를 이용해서 풀어봄.(001111111~111111100)
	 * - 9명 중 2명만 빼면 되는 거니깐 총 합에 2명의 키를 뺏을 때 100이 되는 조합을 구하는 방법
	 * 
	 * Q16637 괄호추가하기1
	 * - 어려웠음
	 * 
	 * 연산자 개수로 비트마스크 비트 수를 구성함
	 * 연산자 개수 = N/2
	 * 최대 괄호 개수 = (N/2+1)/2
	 * 
	 * 예) 연산자 개수가 4개면 4비트 비트마스크로 경우의 수를 조합한다. 최대 괄호 개수는 2개
	 * 1 0 0 0
	 * 0 1 0 0
	 * 0 0 1 0
	 * 0 0 0 1
	 * 1 0 1 0
	 * 0 1 0 1
	 * 1 0 0 1
	 * 이렇게 가능함, 총 경우의 수 7개
	 * 각 경우의 비트 1,0을 boolean 배열로 표시해서 계산하기
	 * true false false false 이런식으로..
	 * 
	 * 그 다음 이제 각 경우에 따라 실제로 계산을 해본다.
	 * true 면 해당 연산자 앞 뒤의 값 더한 후 값 넣기
	 * false 면 큐에 연산자랑 값 넣기
	 * 예) 3+8*2+7-1 수식이 있고 true false true false 라는 경우에 대해 계산을 한다치면
	 * 큐 : 3
	 * 첫번째 연산 true -> 큐lastpoll(3) + 8 = 11 => 큐
	 * 큐 : 11
	 * 두번째 연산 false -> 두번째연산, 다음 숫자 => 큐
	 * 큐 : 11 * 2
	 * 세번째 연산 true -> 큐lastpoll(2) +(3번째연산) 7 = 9 => 큐
	 * 큐 : 11 * 9
	 * 네번째 연산 false -> 네번째연산, 다음숫자 => 큐
	 * 큐 : 11 * 9 - 1
	 * 
	 * 괄호 체크는 완료! 이제 큐가 empty일 때까지 poll해서 계산하기
	 * 11 * 9 - 1 = 98
	 * 
	 * 해당 값이 그전 경우(maxsum)의 sum보다 크면 maxsum 변수에 저장
	 *
	 * 
	 */
}
