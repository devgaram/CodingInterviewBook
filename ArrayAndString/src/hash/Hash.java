package hash;

/*
 * HASH TABLE *전체 배열 탐색 안하는 게 point!
 * 탐색 키의 비교가 아닌 탐색 키에 산술적인 연산을 적용시켜서 항목이 저장되어 있는 테이블의 주소(위치)를 계산하여 바로 접근하는 것
 * 이론적으로 O(1)
 * 예)사전
 * 
 * 배경)
 * 탐색 키가 0~999까지의 정수라고 가정한다면 가장 빠르게 자료를 저장하고 탐색하는 방법은 
 * 1000개의 요소를 가지는 배열을 만들고 탐색 키를 배열의 인덱스라고 생각하는 것이다 ( 시간복잡도 : O(1) )
 * 그러나, 실제로 탐색키는 문자열이거나 매우 큰 숫자이므로 탐색 키를 직접 배열의 인덱스로 하기에는 무리가 있다.
 * 그래서, 해시함수를 통해 각 탐색키를 작은 정수로 사상(매핑)시켜 해시 주소를 생성하고 이 주소를 배열로 구현된 해시 테이블의 인덱스로 만든다.
 * 
 * 해싱의 구조)
 * - 해시테이블은 M개의 버켓(bucket)으로 이루어진다.
 * - 하나의 버켓은 s개의 슬롯(slot)을 가질 수 있으며, 하나의 슬롯에 하나의 항목이 저장된다.
 * - 해시함수의 경우의 수 < 버켓의 수 라서 같은 해시주소로 매핑되는 경우가 발생하는 데 이를 충돌(conflict)라 한다.
 * - 충돌이 발생하면 같은 버켓의 다른 슬롯에 저장한다. 충돌이 자주 발생하면 버켓 내부에서 순차 탐색 시간이 길어져 탐색 성능 저하를 가져온다
 * - 충돌이 버켓에 할당된 슬롯 수보다 많이 발생하여 버켓에 더 이상 항목을 저장할 수 있게 되는 것을 오버플로(overflow)라 한다.
 * 
 * 좋은 해시함수의 조건)
 * - 충돌이 적어야 한다.
 * - 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 한다.
 * - 계산이 빨라야 한다.
 */
public class Hash {
	
	class HashTable {
		
	}
	
}
